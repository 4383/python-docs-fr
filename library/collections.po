# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/library/collections.rst:2
msgid ":mod:`collections` --- High-performance container datatypes"
msgstr ""

#: ../Doc/library/collections.rst:17
msgid ""
"**Source code:** :source:`Lib/collections.py` and :source:`Lib/_abcoll.py`"
msgstr ""

#: ../Doc/library/collections.rst:21
msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:"
"`dict`, :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"Ce module implémente des types de données de conteneurs spécialisés qui "
"apportent des alternatives aux conteneurs natifs de Python plus généraux :"
"class:`dict`, :class:`list`, :class:`set` et :class:`tuple`."

#: ../Doc/library/collections.rst:26
msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

#: ../Doc/library/collections.rst:26
msgid "factory function for creating tuple subclasses with named fields"
msgstr ""
"fonction permettant de créer des sous-classes de ``tuple`` avec des champs "
"nommés"

#: ../Doc/library/collections.rst:27
msgid ":class:`deque`"
msgstr ":class:`deque`"

#: ../Doc/library/collections.rst:27
msgid "list-like container with fast appends and pops on either end"
msgstr ""
"conteneur se comportant comme une liste avec des ajouts et retraits rapides "
"à chaque extrémité"

#: ../Doc/library/collections.rst:28
msgid ":class:`Counter`"
msgstr ":class:`Counter`"

#: ../Doc/library/collections.rst:28
msgid "dict subclass for counting hashable objects"
msgstr "sous-classe de ``dict`` pour compter des objets hachables"

#: ../Doc/library/collections.rst:29
msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

#: ../Doc/library/collections.rst:29
msgid "dict subclass that remembers the order entries were added"
msgstr ""
"sous-classe de ``dict`` qui garde en mémoire l'ordre dans lequel les entrées "
"ont été ajoutées"

#: ../Doc/library/collections.rst:30
msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

#: ../Doc/library/collections.rst:30
msgid "dict subclass that calls a factory function to supply missing values"
msgstr ""
"sous-classe de ``dict`` qui appelle une fonction de fabrication en cas de "
"valeur manquante"

#: ../Doc/library/collections.rst:33
msgid ""
"In addition to the concrete container classes, the collections module "
"provides :ref:`abstract base classes <collections-abstract-base-classes>` "
"that can be used to test whether a class provides a particular interface, "
"for example, whether it is hashable or a mapping."
msgstr ""

#: ../Doc/library/collections.rst:40
msgid ":class:`Counter` objects"
msgstr "Objets :class:`Counter`"

#: ../Doc/library/collections.rst:42
msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr ""
"Ce module fournit un outil pour effectuer rapidement et facilement des "
"dénombrements. Par exemple : ::"

#: ../Doc/library/collections.rst:61
msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting hashable "
"objects. It is an unordered collection where elements are stored as "
"dictionary keys and their counts are stored as dictionary values.  Counts "
"are allowed to be any integer value including zero or negative counts.  The :"
"class:`Counter` class is similar to bags or multisets in other languages."
msgstr ""
"La classe :class:`Counter` est une sous-classe de :class:`dict` qui permet "
"le dénombrement d'objets hachables. Il s'agit d'une collection non ordonnée "
"dans laquelle les éléments sont stockés comme des clés de dictionnaire et "
"leurs nombres d’occurrences respectifs comme leurs valeurs. Ceux-ci peuvent "
"être des entiers relatifs (positifs, négatifs ou nuls). La classe :class:"
"`Counter` est similaire aux sacs ou aux multiensembles dans d'autres "
"langages."

#: ../Doc/library/collections.rst:67
msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr ""
"Les éléments sont comptés à partir d'un itérable ou initialisés à partir "
"d'un autre dictionnaire (ou compteur) :"

#: ../Doc/library/collections.rst:75
msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"Les objets Counter ont une interface de dictionnaire, à l'exception près "
"qu'ils renvoient zéro au lieu de lever une exception :exc:`KeyError` pour "
"des éléments manquants :"

#: ../Doc/library/collections.rst:82
msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr ""
"Mettre un comptage à zéro pour un élément ne le retire pas de l'objet "
"Counter. Il faut utiliser ``del`` pour le supprimer complètement :"

#: ../Doc/library/collections.rst:91
msgid ""
"Counter objects support three methods beyond those available for all "
"dictionaries:"
msgstr ""
"En plus des méthodes disponibles pour tous les dictionnaires, les objets "
"compteurs gèrent trois méthodes supplémentaires :"

#: ../Doc/library/collections.rst:96
msgid ""
"Return an iterator over elements repeating each as many times as its count.  "
"Elements are returned in arbitrary order.  If an element's count is less "
"than one, :meth:`elements` will ignore it."
msgstr ""
"Renvoie un itérateur sur chaque élément en le répétant autant de fois que la "
"valeur du compteur associé. Les éléments sont renvoyés dans un ordre "
"arbitraire. Si le comptage d'un élément est strictement inférieur à 1, "
"alors :meth:`elements` l'ignore."

#: ../Doc/library/collections.rst:106
msgid ""
"Return a list of the *n* most common elements and their counts from the most "
"common to the least.  If *n* is omitted or ``None``, :func:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered arbitrarily:"
msgstr ""

#: ../Doc/library/collections.rst:116
msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"Les éléments sont soustraits à partir d'un itérable ou d'un autre "
"dictionnaire (ou compteur). Cette méthode se comporte comme :meth:`dict."
"update` mais soustrait les nombres d'occurrences au lieu de les remplacer. "
"Les entrées et sorties peuvent être négatives ou nulles."

#: ../Doc/library/collections.rst:126
msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr ""
"Les méthodes usuelles des dictionnaires sont disponibles pour les objets :"
"class:`Counter` à l'exception de deux méthodes qui fonctionnent différemment "
"pour les compteurs."

#: ../Doc/library/collections.rst:131
msgid "This class method is not implemented for :class:`Counter` objects."
msgstr ""
"Cette méthode de classe n'est pas implémentée pour les objets :class:"
"`Counter`."

#: ../Doc/library/collections.rst:135
msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing "
"them.  Also, the *iterable* is expected to be a sequence of elements, not a "
"sequence of ``(key, value)`` pairs."
msgstr ""
"Les éléments sont comptés à partir d'un itérable ou ajoutés d'un autre "
"dictionnaire (ou compteur). Cette méthode se comporte comme :meth:`dict."
"update` mais additionne les nombres d'occurrences au lieu de les remplacer. "
"De plus, l'itérable doit être une séquence d'éléments et non une séquence de "
"paires ``(clé, valeur)``."

#: ../Doc/library/collections.rst:140
msgid "Common patterns for working with :class:`Counter` objects::"
msgstr "Opérations usuelles sur les objets :class:`Counter` : ::"

#: ../Doc/library/collections.rst:152
msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum "
"and maximum of corresponding counts.  Each operation can accept inputs with "
"signed counts, but the output will exclude results with counts of zero or "
"less."
msgstr ""
"Quelques opérations mathématiques sont fournies pour combiner des objets :"
"class:`Counter` afin de créer des multiensembles (des compteurs dont les "
"dénombrements des éléments sont strictement supérieurs à zéro). Les "
"additions et soustractions combinent les compteurs en ajoutant ou "
"retranchant les nombres d'occurrences des éléments correspondants. Les "
"intersections et unions renvoient les minimums et maximums des comptages "
"correspondants. Chaque opération peut accepter des entrées avec des "
"comptages relatifs, mais la sortie exclut les résultats avec des comptages "
"négatifs ou nuls."

#: ../Doc/library/collections.rst:172
msgid ""
"Counters were primarily designed to work with positive integers to represent "
"running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases, "
"this section documents the minimum range and type restrictions."
msgstr ""
"Les compteurs ont été conçus essentiellement pour fonctionner avec des "
"entiers naturels pour représenter les dénombrements en cours ; cependant, "
"les cas d'utilisation nécessitant d'autres types ou des valeurs négatives "
"n'ont pas été écartés. Pour vous aider dans ces cas particuliers, cette "
"section documente la plage minimale et les restrictions de type."

#: ../Doc/library/collections.rst:177
msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ""
"La classe :class:`Counter` est elle-même une sous-classe de dictionnaire "
"sans restriction particulière sur ces clés ou valeurs. Les valeurs ont "
"vocation à être des nombres représentants des comptages, mais il est "
"*possible* de stocker n'importe quel type de valeur."

#: ../Doc/library/collections.rst:181
msgid ""
"The :meth:`most_common` method requires only that the values be orderable."
msgstr ""

#: ../Doc/library/collections.rst:183
msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for :meth:"
"`update` and :meth:`subtract` which allow negative and zero values for both "
"inputs and outputs."
msgstr ""

#: ../Doc/library/collections.rst:189
msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr ""
"Les méthodes de multiensembles sont uniquement conçues pour les cas "
"d'utilisation avec des valeurs positives. Les entrées peuvent contenir des "
"valeurs négatives ou nulles, mais seules les sorties avec des valeurs "
"positives sont créées. Il n'y a pas de restriction de type, mais les types "
"des valeurs doivent gérer l'addition, la soustraction et la comparaison."

#: ../Doc/library/collections.rst:194
msgid ""
"The :meth:`elements` method requires integer counts.  It ignores zero and "
"negative counts."
msgstr ""

#: ../Doc/library/collections.rst:199
msgid ""
"`Counter class <https://code.activestate.com/recipes/576611/>`_ adapted for "
"Python 2.5 and an early `Bag recipe <https://code.activestate.com/"
"recipes/259174/>`_ for Python 2.4."
msgstr ""

#: ../Doc/library/collections.rst:203
msgid "in Smalltalk."
msgstr ""

#: ../Doc/library/collections.rst:205
msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr ""
"L'article Wikipédia sur les `multiensembles <https://fr.wikipedia.org/wiki/"
"Multiensemble>`_ sur Wikipédia (ou `l'article en anglais <https://en."
"wikipedia.org/wiki/Multiset>`_)."

#: ../Doc/library/collections.rst:207
msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"Des guides et exemples à propos des `multiensembles en C++ <http://www."
"java2s.com/Tutorial/Cpp/0380__set-multiset/Catalog0380__set-multiset.htm>`_."

#: ../Doc/library/collections.rst:210
msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr ""
"Pour les opérations mathématiques sur les multiensembles et leurs "
"applications, voir *Knuth, Donald. The Art of Computer Programming Volume "
"II, Section 4.6.3, Exercise 19*."

#: ../Doc/library/collections.rst:214
msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`."
msgstr ""

#: ../Doc/library/collections.rst:217
msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) --> AA AB AC BB BC CC"
msgstr ""

#: ../Doc/library/collections.rst:221
msgid ":class:`deque` objects"
msgstr "Objets :class:`deque`"

#: ../Doc/library/collections.rst:225
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""
"Renvoie un nouvel objet *deque* initialisé de gauche à droite (en utilisant :"
"meth:`append`) avec les données d'*iterable*. Si *iterable* n'est pas "
"spécifié, alors la nouvelle *deque* est vide."

#: ../Doc/library/collections.rst:228
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same O(1) performance in either direction."
msgstr ""
"Les *deques* sont une généralisation des piles et des files (*deque* se "
"prononce \"*dèque*\" et est l'abréviation de l'anglais *double-ended "
"queue*) : il est possible d'ajouter et retirer des éléments par les deux "
"bouts des *deques*. Celles-ci gèrent des ajouts et des retraits utilisables "
"par de multiples fils d'exécution (*thread-safe*) et efficients du point de "
"vue de la mémoire des deux côtés de la *deque*, avec approximativement la "
"même performance en *O(1)* dans les deux sens."

#: ../Doc/library/collections.rst:233
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur O(n) memory movement costs for "
"``pop(0)`` and ``insert(0, v)`` operations which change both the size and "
"position of the underlying data representation."
msgstr ""
"Bien que les les objets :class:`list` gèrent des opérations similaires, ils "
"sont optimisés pour des opérations qui ne changent pas la taille de la "
"liste. Les opérations ``pop(0)`` et ``insert(0, v)`` qui changent la taille "
"et la position de la représentation des données sous-jacentes entraînent des "
"coûts de déplacement de mémoire en *O(n)*."

#: ../Doc/library/collections.rst:240
msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""
"Si *maxlen* n'est pas spécifié ou vaut *None*, les *deques* peuvent "
"atteindre une taille arbitraire. Sinon, la *deque* est limitée par cette "
"taille maximale. Une fois que celle-ci est atteinte, un ajout d'un ou "
"plusieurs éléments engendre la suppression du nombre correspondant "
"d'éléments à l'autre extrémité de la *deque*. Les *deques* à longueur "
"limitée apportent des fonctionnalités similaire au filtre ``tail`` d'Unix. "
"Elles sont aussi utiles pour le suivi de transactions et autres lots de "
"données où seule l'activité récente est intéressante."

#: ../Doc/library/collections.rst:248
msgid "Added *maxlen* parameter."
msgstr ""

#: ../Doc/library/collections.rst:251
msgid "Deque objects support the following methods:"
msgstr "Les objets *deques* gèrent les méthodes suivantes :"

#: ../Doc/library/collections.rst:256
msgid "Add *x* to the right side of the deque."
msgstr "Ajoute *x* à l'extrémité droite de la *deque*."

#: ../Doc/library/collections.rst:261
msgid "Add *x* to the left side of the deque."
msgstr "Ajoute *x* à l'extrémité gauche de la *deque*."

#: ../Doc/library/collections.rst:266
msgid "Remove all elements from the deque leaving it with length 0."
msgstr ""
"Supprime tous les éléments de la *deque* et la laisse avec une longueur de 0."

#: ../Doc/library/collections.rst:271
msgid "Count the number of deque elements equal to *x*."
msgstr "Compte le nombre d'éléments de la *deque* égaux à *x*."

#: ../Doc/library/collections.rst:277
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""
"Étend la *deque* en ajoutant les éléments de l'itérable en argument à son "
"extrémité droite."

#: ../Doc/library/collections.rst:283
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""
"Étend la *deque* en ajoutant les éléments d'*iterable* à son extrémité "
"gauche. Dans ce cas, notez que la série d'ajouts inverse l'ordre des "
"éléments de l'argument itérable."

#: ../Doc/library/collections.rst:290
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""
"Retire et renvoie un élément de l'extrémité droite de la *deque*. S'il n'y a "
"aucun élément, lève une exception :exc:`IndexError`."

#: ../Doc/library/collections.rst:296
msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""
"Retire et renvoie un élément de l'extrémité gauche de la *deque*. S'il n'y a "
"aucun élément, lève une exception :exc:`IndexError`."

#: ../Doc/library/collections.rst:302
msgid ""
"Removed the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""

#: ../Doc/library/collections.rst:309
msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr ""
"Inverse le sens des éléments de la *deque* sans créer de copie et renvoie "
"``None``."

#: ../Doc/library/collections.rst:315
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left.  Rotating one step to the right is equivalent to: ``d.appendleft(d."
"pop())``."
msgstr ""

#: ../Doc/library/collections.rst:320
msgid "Deque objects also provide one read-only attribute:"
msgstr ""
"Les objets *deques* fournissent également un attribut en lecture seule :"

#: ../Doc/library/collections.rst:324
msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "La taille maximale d'une *deque*, ou ``None`` si illimitée."

#: ../Doc/library/collections.rst:329
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as "
"``d[-1]``.  Indexed access is O(1) at both ends but slows to O(n) in the "
"middle.  For fast random access, use lists instead."
msgstr ""
"En plus des méthodes précédentes, les *deques* gèrent l'itération, la "
"sérialisation, ``len(d)``, ``reversed(d)``, ``copy.copy(d)``, ``copy."
"deepcopy(d)``, le test d'appartenance avec l'opérateur :keyword:`in`, et les "
"références en indice comme ``d[-1]``. L'accès par indice est en *O(1)* aux "
"extrémités mais en *O(n)* au milieu. Pour des accès aléatoires rapides, il "
"est préférable d'utiliser des listes."

#: ../Doc/library/collections.rst:335 ../Doc/library/collections.rst:597
msgid "Example:"
msgstr "Exemple :"

#: ../Doc/library/collections.rst:392
msgid ":class:`deque` Recipes"
msgstr "Cas pratiques utilisant :class:`deque`"

#: ../Doc/library/collections.rst:394
msgid "This section shows various approaches to working with deques."
msgstr ""
"Cette partie montre diverses approches afin de travailler avec les *deques*."

#: ../Doc/library/collections.rst:396
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""
"Les *deques* à taille limitée apportent une fonctionnalité similaire au "
"filtre ``tail`` d'Unix : ::"

#: ../Doc/library/collections.rst:403
msgid ""
"Another approach to using deques is to maintain a sequence of recently added "
"elements by appending to the right and popping to the left::"
msgstr ""
"Une autre approche d'utilisation des *deques* est de maintenir une séquence "
"d'éléments récemment ajoutés en les ajoutant à droite et en retirant les "
"anciens par la gauche : ::"

#: ../Doc/library/collections.rst:418
msgid ""
"The :meth:`rotate` method provides a way to implement :class:`deque` slicing "
"and deletion.  For example, a pure Python implementation of ``del d[n]`` "
"relies on the :meth:`rotate` method to position elements to be popped::"
msgstr ""

#: ../Doc/library/collections.rst:427
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`rotate` to bring a target element to the left side of the deque. Remove old "
"entries with :meth:`popleft`, add new entries with :meth:`extend`, and then "
"reverse the rotation. With minor variations on that approach, it is easy to "
"implement Forth style stack manipulations such as ``dup``, ``drop``, "
"``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""

#: ../Doc/library/collections.rst:437
msgid ":class:`defaultdict` objects"
msgstr "Objets :class:`defaultdict`"

#: ../Doc/library/collections.rst:441
msgid ""
"Returns a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""
"Renvoie un nouvel objet qui se comporte comme un dictionnaire. :class:"
"`defaultdic` est une sous-classe de la la classe native :class:`dict`. Elle "
"surcharge une méthode et ajoute une variable d'instance modifiable. Les "
"autres fonctionnalités sont les mêmes que celles des objets :class:`dict` et "
"ne sont pas documentées ici."

#: ../Doc/library/collections.rst:446
msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""
"Le premier argument fournit la valeur initiale de l'attribut :attr:"
"`default_factory` qui doit être un objet appelable sans paramètre ou "
"``None``, sa valeur par défaut. Tous les autres arguments sont traités comme "
"si on les passait au constructeur de :class:`dict`, y compris les arguments "
"nommés."

#: ../Doc/library/collections.rst:453
msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""
"En plus des opérations usuelles de :class:`dict`, les objets :class:"
"`defaultdict` gèrent les méthodes supplémentaires suivantes :"

#: ../Doc/library/collections.rst:458
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""
"Si l'attribut :attr:`default_factory` est ``None``, lève une exception :exc:"
"`KeyError` avec *key* comme argument."

#: ../Doc/library/collections.rst:461
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""
"Si :attr:`default_fatory`` ne vaut pas ``None``, cet attribut est appelé "
"sans argument pour fournir une valeur par défaut pour la *key* demandée. "
"Cette valeur est insérée dans le dictionnaire avec pour clé *key* et est "
"renvoyée."

#: ../Doc/library/collections.rst:465
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""
"Si appeler :attr:`default_factory` lève une exception, celle-ci est "
"transmise inchangée."

#: ../Doc/library/collections.rst:468
msgid ""
"This method is called by the :meth:`__getitem__` method of the :class:`dict` "
"class when the requested key is not found; whatever it returns or raises is "
"then returned or raised by :meth:`__getitem__`."
msgstr ""
"Cette méthode est appelée par la méthode :meth:`__getitem__` de la classe :"
"class:`dict` lorsque la clé demandée n'est pas trouvée. Ce qu'elle renvoie "
"ou lève est alors renvoyé ou levé par :meth:`__getitem__`."

#: ../Doc/library/collections.rst:472
msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides :"
"meth:`__getitem__`. This means that :meth:`get` will, like normal "
"dictionaries, return ``None`` as a default rather than using :attr:"
"`default_factory`."
msgstr ""
"Remarquez que :meth:`__missing__` n'est *pas* appelée pour les opérations "
"autres que :meth:`__getitem__`. Cela signifie que :meth:`get` renvoie "
"``None`` comme les dictionnaires natifs dans les cas triviaux et n'utilise "
"pas :attr:`default_factory`."

#: ../Doc/library/collections.rst:478
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr "Les objets :class:`defaultdict` gèrent la variable d'instance :"

#: ../Doc/library/collections.rst:483
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""
"Cet attribut est utilisé par la méthode :meth:`__missing__` ; il est "
"initialisé par le premier argument passé au constructeur, s'il est spécifié, "
"sinon par ``None``."

#: ../Doc/library/collections.rst:489
msgid ":class:`defaultdict` Examples"
msgstr "Exemples utilisant :class:`defaultdict`"

#: ../Doc/library/collections.rst:491
msgid ""
"Using :class:`list` as the :attr:`default_factory`, it is easy to group a "
"sequence of key-value pairs into a dictionary of lists:"
msgstr ""

#: ../Doc/library/collections.rst:502
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:"
"`default_factory` function which returns an empty :class:`list`.  The :meth:"
"`list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""

#: ../Doc/library/collections.rst:517
msgid ""
"Setting the :attr:`default_factory` to :class:`int` makes the :class:"
"`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""

#: ../Doc/library/collections.rst:529
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`default_factory` function calls :func:`int` to supply a default count "
"of zero.  The increment operation then builds up the count for each letter."
msgstr ""

#: ../Doc/library/collections.rst:533
msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use :func:`itertools.repeat` which can supply any constant "
"value (not just zero):"
msgstr ""

#: ../Doc/library/collections.rst:545
msgid ""
"Setting the :attr:`default_factory` to :class:`set` makes the :class:"
"`defaultdict` useful for building a dictionary of sets:"
msgstr ""

#: ../Doc/library/collections.rst:558
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ""
":func:`namedtuple`: fonction de construction pour *n-uplets* (*tuples*) avec "
"des champs nommés"

#: ../Doc/library/collections.rst:560
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""
"Les tuples nommés assignent une signification à chacun de leur élément, ce "
"qui rend le code plus lisible et explicite. Ils peuvent être utilisés "
"partout où les tuples natifs sont utilisés, et ils ajoutent la possibilité "
"d'accéder à leurs champs grâce à leur nom au lieu de leur index de position."

#: ../Doc/library/collections.rst:566
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with typename and field_names) and a helpful :meth:"
"`__repr__` method which lists the tuple contents in a ``name=value`` format."
msgstr ""
"Renvoie une nouvelle sous-classe de ``tuple`` appelée *typename*. Elle est "
"utilisée pour créer des objets se comportant comme les *tuples* qui ont des "
"champs accessibles par recherche d'attribut en plus d'être indexables et "
"itérables. Les instances de cette sous-classe possèdent aussi une "
"*docstring* explicite (avec *type_name* et les *field_names*) et une "
"méthode :meth:`__repr__` pratique qui liste le contenu du tuple au format "
"``nom=valeur``."

#: ../Doc/library/collections.rst:572
msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr ""
"*field_names* peut être une séquence de chaînes de caractères telle que "
"``['x', 'y']`` ou bien une unique chaîne de caractères où les noms de champs "
"sont séparés par un espace et/ou une virgule, par exemple ``'x y'`` ou ``'x, "
"y'``."

#: ../Doc/library/collections.rst:576
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, *print*, "
"or *raise*."
msgstr ""

#: ../Doc/library/collections.rst:582
msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def`` "
"and the duplicate fieldname ``abc``."
msgstr ""
"Si *rename* vaut ``True``, alors les noms de champs invalides sont "
"automatiquement renommés en noms positionnels. Par exemple, ``['abc', 'def', "
"'ghi', 'abc']`` est converti en ``['abc, '_1', 'ghi', '_3']`` afin "
"d'éliminer le mot-clé ``def`` et le doublon de ``abc``."

#: ../Doc/library/collections.rst:587
msgid ""
"If *verbose* is true, the class definition is printed just before being "
"built."
msgstr ""

#: ../Doc/library/collections.rst:589
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""
"Les instances de tuples nommés n'ont pas de dictionnaires propres, elles "
"sont donc légères et ne requièrent pas plus de mémoire que les tuples natifs."

#: ../Doc/library/collections.rst:594
msgid "added support for *rename*."
msgstr ""

#: ../Doc/library/collections.rst:664
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""
"Les tuples nommés sont particulièrement utiles pour associer des noms de "
"champs à des tuples renvoyés par les modules :mod:`csv` ou :mod:"
"`sqlite3` : ::"

#: ../Doc/library/collections.rst:680
msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and one attribute.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""

#: ../Doc/library/collections.rst:686
msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""
"Méthode de classe qui construit une nouvelle instance à partir d'une "
"séquence ou d'un itérable existant."

#: ../Doc/library/collections.rst:696
msgid ""
"Return a new :class:`OrderedDict` which maps field names to their "
"corresponding values::"
msgstr ""

#: ../Doc/library/collections.rst:703
msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr "Renvoie un :class:`OrderedDict` au lieu d'un :class:`dict` natif."

#: ../Doc/library/collections.rst:708
msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values::"
msgstr ""
"Renvoie une nouvelle instance du tuple nommé en remplaçant les champs "
"spécifiés par leurs nouvelles valeurs : ::"

#: ../Doc/library/collections.rst:720
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""
"Tuple de chaînes de caractères listant les noms de champs. Pratique pour "
"l'introspection et pour créer de nouveaux types de tuples nommés à partir "
"d'existants."

#: ../Doc/library/collections.rst:733
msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""
"Pour récupérer un champ dont le nom est une chaîne de caractères, utilisez "
"la fonction :func:`getattr` :"

#: ../Doc/library/collections.rst:739
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""
"Pour convertir un dictionnaire en tuple nommé, utilisez l'opérateur double-"
"étoile (comme expliqué dans :ref:`tut-unpacking-arguments`) :"

#: ../Doc/library/collections.rst:746
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""
"Il est aisé d'ajouter ou de modifier les fonctionnalités des tuples nommés "
"grâce à l'héritage puisqu'il s'agit de simples classes. Voici comment "
"ajouter un champ calculé avec une longueur fixe d'affichage :"

#: ../Doc/library/collections.rst:763
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""
"La sous-classe ci-dessus définit ``__slots__`` comme un tuple vide. Cela "
"permet de garder une emprunte mémoire faible en empêchant la création de "
"dictionnaire d'instance."

#: ../Doc/library/collections.rst:766
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`_fields` attribute:"
msgstr ""

#: ../Doc/library/collections.rst:771
msgid ""
"Default values can be implemented by using :meth:`_replace` to customize a "
"prototype instance:"
msgstr ""

#: ../Doc/library/collections.rst:778
msgid ""
"Enumerated constants can be implemented with named tuples, but it is simpler "
"and more efficient to use a simple class declaration:"
msgstr ""

#: ../Doc/library/collections.rst:789
msgid ""
"`Named tuple recipe <https://code.activestate.com/recipes/500261/>`_ adapted "
"for Python 2.4."
msgstr ""

#: ../Doc/library/collections.rst:794
msgid ":class:`OrderedDict` objects"
msgstr "Objets :class:`OrderedDict`"

#: ../Doc/library/collections.rst:796
msgid ""
"Ordered dictionaries are just like regular dictionaries but they remember "
"the order that items were inserted.  When iterating over an ordered "
"dictionary, the items are returned in the order their keys were first added."
msgstr ""
"En plus de se comporter comme des dictionnaires natifs, les dictionnaires "
"ordonnés mémorisent l'ordre dans lequel les éléments ont été insérés. Quand "
"on itère sur un dictionnaire ordonné, les éléments sont renvoyés dans "
"l'ordre d'insertion des clés."

#: ../Doc/library/collections.rst:802
msgid ""
"Return an instance of a dict subclass, supporting the usual :class:`dict` "
"methods.  An *OrderedDict* is a dict that remembers the order that keys were "
"first inserted. If a new entry overwrites an existing entry, the original "
"insertion position is left unchanged.  Deleting an entry and reinserting it "
"will move it to the end."
msgstr ""
"Renvoie une instance d'une sous-classe de ``dict`` qui gère les méthodes "
"usuelles de :class:`dict`. Un objet *OrderedDict* est un dictionnaire qui "
"mémorise l'ordre d'insertion des clés. Si une nouvelle entrée en écrase une "
"autre, sa position reste inchangé. Si une entrée est supprimée puis "
"réinsérée, elle est placée en dernière position."

#: ../Doc/library/collections.rst:812
msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in LIFO order if *last* is true "
"or FIFO order if false."
msgstr ""

#: ../Doc/library/collections.rst:816
msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr ""
"En plus des méthodes usuelles des dictionnaires, les dictionnaires ordonnés "
"gèrent l'itération en sens inverse grâce à :func:`reversed`."

#: ../Doc/library/collections.rst:819
msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are implemented as ``list(od1.items())==list(od2.items())``. Equality tests "
"between :class:`OrderedDict` objects and other :class:`Mapping` objects are "
"order-insensitive like regular dictionaries.  This allows :class:"
"`OrderedDict` objects to be substituted anywhere a regular dictionary is "
"used."
msgstr ""

#: ../Doc/library/collections.rst:826
msgid ""
"The :class:`OrderedDict` constructor and :meth:`update` method both accept "
"keyword arguments, but their order is lost because Python's function call "
"semantics pass-in keyword arguments using a regular unordered dictionary."
msgstr ""

#: ../Doc/library/collections.rst:832
msgid ""
"`Equivalent OrderedDict recipe <https://code.activestate.com/recipes/576693/"
">`_ that runs on Python 2.4 or later."
msgstr ""

#: ../Doc/library/collections.rst:836
msgid ":class:`OrderedDict` Examples and Recipes"
msgstr "Exemples et cas pratiques utilisant :class:`OrderDict`"

#: ../Doc/library/collections.rst:838
msgid ""
"Since an ordered dictionary remembers its insertion order, it can be used in "
"conjunction with sorting to make a sorted dictionary::"
msgstr ""
"Puisqu'un dictionnaire ordonné mémorise l'ordre d'insertion de ses éléments, "
"il peut être utilisé conjointement avec un classement pour créer un "
"dictionnaire trié : ::"

#: ../Doc/library/collections.rst:856
msgid ""
"The new sorted dictionaries maintain their sort order when entries are "
"deleted.  But when new keys are added, the keys are appended to the end and "
"the sort is not maintained."
msgstr ""
"Les nouveaux dictionnaires triés gardent leur classement quand des entrées "
"sont supprimées, mais si de nouvelles clés sont ajoutées, celles-ci sont "
"ajoutée à la fin et le classement est perdu."

#: ../Doc/library/collections.rst:860
msgid ""
"It is also straight-forward to create an ordered dictionary variant that "
"remembers the order the keys were *last* inserted. If a new entry overwrites "
"an existing entry, the original insertion position is changed and moved to "
"the end::"
msgstr ""
"Il est également facile de créer une variante de dictionnaire ordonné qui "
"retient l'ordre dans lequel les clés ont été insérées *en dernier*. Si une "
"nouvelle entrée écrase une existante, la position d'insertion d'origine est "
"modifiée et déplacée à la fin : ::"

#: ../Doc/library/collections.rst:873
msgid ""
"An ordered dictionary can be combined with the :class:`Counter` class so "
"that the counter remembers the order elements are first encountered::"
msgstr ""
"Un dictionnaire ordonné peut être combiné avec la classe :class:`Counter` "
"afin de mémoriser l'ordre dans lequel les éléments ont été ajoutés pour la "
"première fois : ::"

#: ../Doc/library/collections.rst:889
msgid "Collections Abstract Base Classes"
msgstr "Classes de base abstraites de collections"

#: ../Doc/library/collections.rst:891
msgid ""
"The collections module offers the following :term:`ABCs <abstract base "
"class>`:"
msgstr ""
"Le module collections apporte les :term:`ABC <abstract base class>` "
"suivantes :"

#: ../Doc/library/collections.rst:894
msgid "ABC"
msgstr "ABC"

#: ../Doc/library/collections.rst:894
msgid "Inherits from"
msgstr "Hérite de"

#: ../Doc/library/collections.rst:894
msgid "Abstract Methods"
msgstr "Méthodes abstraites"

#: ../Doc/library/collections.rst:894
msgid "Mixin Methods"
msgstr "Méthodes *mixin*"

#: ../Doc/library/collections.rst:896
msgid ":class:`Container`"
msgstr ":class:`Container`"

#: ../Doc/library/collections.rst:896
msgid "``__contains__``"
msgstr "``__contains__``"

#: ../Doc/library/collections.rst:897
msgid ":class:`Hashable`"
msgstr ":class:`Hashable`"

#: ../Doc/library/collections.rst:897
msgid "``__hash__``"
msgstr "``__hash__``"

#: ../Doc/library/collections.rst:898 ../Doc/library/collections.rst:899
msgid ":class:`Iterable`"
msgstr ":class:`Iterable`"

#: ../Doc/library/collections.rst:898 ../Doc/library/collections.rst:899
msgid "``__iter__``"
msgstr "``__iter__``"

#: ../Doc/library/collections.rst:899
msgid ":class:`Iterator`"
msgstr ":class:`Iterator`"

#: ../Doc/library/collections.rst:899
msgid "``next``"
msgstr ""

#: ../Doc/library/collections.rst:900 ../Doc/library/collections.rst:934
msgid ":class:`Sized`"
msgstr ":class:`Sized`"

#: ../Doc/library/collections.rst:900 ../Doc/library/collections.rst:934
msgid "``__len__``"
msgstr "``__len__``"

#: ../Doc/library/collections.rst:901
msgid ":class:`Callable`"
msgstr ":class:`Callable`"

#: ../Doc/library/collections.rst:901
msgid "``__call__``"
msgstr "``__call__``"

#: ../Doc/library/collections.rst:903 ../Doc/library/collections.rst:907
msgid ":class:`Sequence`"
msgstr ":class:`Sequence`"

#: ../Doc/library/collections.rst:903 ../Doc/library/collections.rst:913
#: ../Doc/library/collections.rst:923
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ":class:`Sized`, :class:`Iterable`, :class:`Container`"

#: ../Doc/library/collections.rst:903
msgid "``__getitem__``, ``__len__``"
msgstr "``__getitem__``, ``__len__``"

#: ../Doc/library/collections.rst:903
msgid ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index``, and ``count``"
msgstr ""
"``__contains__``, ``__iter__``, ``__reversed__``, ``index`` et ``count``"

#: ../Doc/library/collections.rst:907
msgid ":class:`MutableSequence`"
msgstr ":class:`MutableSequence`"

#: ../Doc/library/collections.rst:907
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__len__``, ``insert``"

#: ../Doc/library/collections.rst:907
msgid ""
"Inherited :class:`Sequence` methods and ``append``, ``reverse``, ``extend``, "
"``pop``, ``remove``, and ``__iadd__``"
msgstr ""
"Méthodes héritées de :class:`Sequence`, et ``append``, ``reverse``, "
"``extend``, ``pop``, ``remove`` et ``__iadd__``"

#: ../Doc/library/collections.rst:913 ../Doc/library/collections.rst:917
msgid ":class:`Set`"
msgstr ":class:`Set`"

#: ../Doc/library/collections.rst:913
msgid "``__contains__``, ``__iter__``, ``__len__``"
msgstr "``__contains__``, ``__iter__``, ``__len__``"

#: ../Doc/library/collections.rst:913
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__xor__``, and ``isdisjoint``"
msgstr ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__``, ``__sub__``, ``__xor__`` et ``isdisjoint``"

#: ../Doc/library/collections.rst:917
msgid ":class:`MutableSet`"
msgstr ":class:`MutableSet`"

#: ../Doc/library/collections.rst:917
msgid "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"
msgstr "``__contains__``, ``__iter__``, ``__len__``, ``add``, ``discard``"

#: ../Doc/library/collections.rst:917
msgid ""
"Inherited :class:`Set` methods and ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""
"Méthodes héritées de :class:`Set`, et ``clear``, ``pop``, ``remove``, "
"``__ior__``, ``__iand__``, ``__ixor__`` et ``__isub__``"

#: ../Doc/library/collections.rst:923 ../Doc/library/collections.rst:927
msgid ":class:`Mapping`"
msgstr ":class:`Mapping`"

#: ../Doc/library/collections.rst:923
msgid "``__getitem__``, ``__iter__``, ``__len__``"
msgstr "``__getitem__``, ``__iter__``, ``__len__``"

#: ../Doc/library/collections.rst:923
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"
msgstr ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__`` et "
"``__ne__``"

#: ../Doc/library/collections.rst:927
msgid ":class:`MutableMapping`"
msgstr ":class:`MutableMapping`"

#: ../Doc/library/collections.rst:927
msgid ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"
msgstr ""
"``__getitem__``, ``__setitem__``, ``__delitem__``, ``__iter__``, ``__len__``"

#: ../Doc/library/collections.rst:927
msgid ""
"Inherited :class:`Mapping` methods and ``pop``, ``popitem``, ``clear``, "
"``update``, and ``setdefault``"
msgstr ""
"Méthodes héritées de :class:`Mapping`, et ``pop``, ``popitem``, ``clear``, "
"``update`` et ``setdefault``"

#: ../Doc/library/collections.rst:934 ../Doc/library/collections.rst:939
msgid ":class:`MappingView`"
msgstr ":class:`MappingView`"

#: ../Doc/library/collections.rst:935
msgid ":class:`ItemsView`"
msgstr ":class:`ItemsView`"

#: ../Doc/library/collections.rst:935 ../Doc/library/collections.rst:937
msgid ":class:`MappingView`, :class:`Set`"
msgstr ":class:`MappingView`, :class:`Set`"

#: ../Doc/library/collections.rst:935 ../Doc/library/collections.rst:937
#: ../Doc/library/collections.rst:939
msgid "``__contains__``, ``__iter__``"
msgstr "``__contains__``, ``__iter__``"

#: ../Doc/library/collections.rst:937
msgid ":class:`KeysView`"
msgstr ":class:`KeysView`"

#: ../Doc/library/collections.rst:939
msgid ":class:`ValuesView`"
msgstr ":class:`ValuesView`"

#: ../Doc/library/collections.rst:948
msgid ""
"ABCs for classes that provide respectively the methods :meth:"
"`__contains__`, :meth:`__hash__`, :meth:`__len__`, and :meth:`__call__`."
msgstr ""
"ABC pour les classes qui définissent respectivement les méthodes :meth:"
"`__contains__`, :meth:`__hash__`, :meth:`__len__` et :meth:`__call__`."

#: ../Doc/library/collections.rst:953
msgid ""
"ABC for classes that provide the :meth:`__iter__` method. See also the "
"definition of :term:`iterable`."
msgstr ""

#: ../Doc/library/collections.rst:958
msgid ""
"ABC for classes that provide the :meth:`~iterator.__iter__` and :meth:"
"`~iterator.next` methods.  See also the definition of :term:`iterator`."
msgstr ""

#: ../Doc/library/collections.rst:964
msgid "ABCs for read-only and mutable :term:`sequences <sequence>`."
msgstr "ABC pour les :term:`séquences <sequence>` immuables et muables."

#: ../Doc/library/collections.rst:969
msgid "ABCs for read-only and mutable sets."
msgstr "ABC pour les ensembles immuables et muables."

#: ../Doc/library/collections.rst:974
msgid "ABCs for read-only and mutable :term:`mappings <mapping>`."
msgstr ""
"ABC pour les :term:`tables de correspondances <mapping>` immuables et "
"muables."

#: ../Doc/library/collections.rst:981
msgid ""
"ABCs for mapping, items, keys, and values :term:`views <dictionary view>`."
msgstr ""
"ABC pour les :term:`vues<dictionary view>` de *mappings* (tableaux de "
"correspondances), d'éléments, de clés et de valeurs."

#: ../Doc/library/collections.rst:984
msgid ""
"These ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr ""
"Ces ABC permettent de demander à des classes ou à des instances si elles "
"fournissent des fonctionnalités particulières, par exemple ::"

#: ../Doc/library/collections.rst:991
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to develop "
"classes supporting container APIs.  For example, to write a class supporting "
"the full :class:`Set` API, it only necessary to supply the three underlying "
"abstract methods: :meth:`__contains__`, :meth:`__iter__`, and :meth:"
"`__len__`. The ABC supplies the remaining methods such as :meth:`__and__` "
"and :meth:`isdisjoint` ::"
msgstr ""

#: ../Doc/library/collections.rst:1020
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr ""
"Notes à propos de l'utilisation de :class:`Set` et :class:`MutableSet` comme "
"*mixin* :"

#: ../Doc/library/collections.rst:1023
msgid ""
"Since some set operations create new sets, the default mixin methods need a "
"way to create new instances from an iterable. The class constructor is "
"assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal classmethod called :meth:"
"`_from_iterable` which calls ``cls(iterable)`` to produce a new set. If the :"
"class:`Set` mixin is being used in a class with a different constructor "
"signature, you will need to override :meth:`_from_iterable` with a "
"classmethod that can construct new instances from an iterable argument."
msgstr ""
"Comme une partie des opérations sur les ensembles créent de nouveaux "
"ensembles, les méthodes *mixins* par défaut ont besoin d'un moyen de créer "
"de nouvelles instances à partir d'un itérable. Le constructeur de classe est "
"supposé avoir une signature de la forme ``ClassName(iterable)``. Cette "
"supposition est faite par une méthode de classe interne appelée :meth:"
"`_from_iterable` qui appelle ``cls(iterable)`` pour construire un nouvel "
"ensemble. Si le :class:`Set` *mixin* est utilisé dans une classe avec un "
"constructeur de signature différente, vous devrez surcharger :meth:"
"`_from_iterable` avec une méthode de classe qui peut construire de nouvelles "
"instances à partir d'un argument itérable."

#: ../Doc/library/collections.rst:1034
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`__le__` and :meth:`__ge__`, then the other "
"operations will automatically follow suit."
msgstr ""
"Pour surcharger les comparaisons (a priori pour la rapidité, puisque la "
"sémantique est fixe), il faut redéfinir :meth:`__le__` et :meth:`__ge__`, "
"puis les autres opérations seront automatiquement adaptées."

#: ../Doc/library/collections.rst:1039
msgid ""
"The :class:`Set` mixin provides a :meth:`_hash` method to compute a hash "
"value for the set; however, :meth:`__hash__` is not defined because not all "
"sets are hashable or immutable.  To add set hashability using mixins, "
"inherit from both :meth:`Set` and :meth:`Hashable`, then define ``__hash__ = "
"Set._hash``."
msgstr ""
"La classe *mixin* :class:`Set` apporte une méthode :meth:`_hash` pour "
"calculer une valeur de hachage pour l'ensemble ; cependant :meth:`__hash__` "
"n'est pas défini car tous les ensembles ne sont pas hachables ou immuables. "
"Pour rendre un ensemble hachable en utilisant les *mixins*, héritez de :meth:"
"`Set` et de :meth:`Hashable`, puis définissez ``__hash__ = Set._hash``."

#: ../Doc/library/collections.rst:1047
msgid ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ for an "
"example built on :class:`MutableSet`."
msgstr ""
"`OrderedSet recipe <https://code.activestate.com/recipes/576694/>`_ pour un "
"exemple construit sur :class:`MutableSet`."

#: ../Doc/library/collections.rst:1050
msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr ""
"Pour plus d'informations à propos des ABC, voir le module :mod:`abc` et la :"
"pep:`3119`."
