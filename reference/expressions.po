# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/reference/expressions.rst:6
msgid "Expressions"
msgstr "Expressions"

#: ../Doc/reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""
"Ce chapitre explique la signification des éléments des expressions en Python."

#: ../Doc/reference/expressions.rst:14
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**Notes sur la syntaxe :** dans ce chapitre et le suivant, nous utilisons la "
"notation BNF étendue pour décrire la syntaxe, pas l'analyse lexicale. Quand "
"une règle de syntaxe est de la forme"

#: ../Doc/reference/expressions.rst:23
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"et qu'aucune sémantique n'est donnée, la sémantique de ``name`` est la même "
"que celle de ``othername``."

#: ../Doc/reference/expressions.rst:30
msgid "Arithmetic conversions"
msgstr "Conversions arithmétiques"

#: ../Doc/reference/expressions.rst:34
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" the arguments are "
"coerced using the coercion rules listed at  :ref:`coercion-rules`.  If both "
"arguments are standard numeric types, the following coercions are applied:"
msgstr ""

#: ../Doc/reference/expressions.rst:39
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""
"Si l'un des deux arguments est du type nombre complexe, l'autre est converti "
"en nombre complexe ;"

#: ../Doc/reference/expressions.rst:41
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""
"sinon, si l'un des arguments est un nombre à virgule flottante, l'autre est "
"converti en nombre à virgule flottante ;"

#: ../Doc/reference/expressions.rst:44
msgid ""
"otherwise, if either argument is a long integer, the other is converted to "
"long integer;"
msgstr ""

#: ../Doc/reference/expressions.rst:47
msgid "otherwise, both must be plain integers and no conversion is necessary."
msgstr ""

#: ../Doc/reference/expressions.rst:49
msgid ""
"Some additional rules apply for certain operators (e.g., a string left "
"argument to the '%' operator). Extensions can define their own coercions."
msgstr ""

#: ../Doc/reference/expressions.rst:56
msgid "Atoms"
msgstr "Atomes"

#: ../Doc/reference/expressions.rst:60
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in reverse quotes or in "
"parentheses, brackets or braces are also categorized syntactically as "
"atoms.  The syntax for atoms is:"
msgstr ""

#: ../Doc/reference/expressions.rst:75
msgid "Identifiers (Names)"
msgstr "Identifiants (noms)"

#: ../Doc/reference/expressions.rst:81
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"Un identifiant qui apparaît en tant qu'atome est un nom. Lisez la section :"
"ref:`identifiers` pour la définition lexicale et la section :ref:`naming` "
"pour la documentation sur les noms et les liaisons afférentes."

#: ../Doc/reference/expressions.rst:87
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"Quand un nom est lié à un objet, l'évaluation de l'atome produit cet objet. "
"Quand le nom n'est pas lié, toute tentative de l'évaluer lève une exception :"
"exc:`NameError`."

#: ../Doc/reference/expressions.rst:95
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**Transformation des noms privés :** lorsqu'un identificateur qui apparaît "
"textuellement dans la définition d'une classe commence par deux (ou plus) "
"caractères de soulignement et ne se termine pas par deux (ou plus) "
"caractères de soulignement, il est considéré comme un :dfn:`nom privé "
"<private name>` de cette classe. Les noms privés sont transformés en une "
"forme plus longue avant que le code ne soit généré pour eux. La "
"transformation insère le nom de la classe, avec les soulignés enlevés et un "
"seul souligné inséré devant le nom.  Par exemple, l'identificateur "
"``__spam`` apparaissant dans une classe nommée ``Ham`` est transformé en "
"``_Ham__spam``. Cette transformation est indépendante du contexte syntaxique "
"dans lequel l'identificateur est utilisé. Si le nom transformé est "
"extrêmement long (plus de 255 caractères), l'implémentation peut le "
"tronquer. Si le nom de la classe est constitué uniquement de traits de "
"soulignement, aucune transformation n'est effectuée."

#: ../Doc/reference/expressions.rst:112
msgid "Literals"
msgstr "Littéraux"

#: ../Doc/reference/expressions.rst:116
msgid "Python supports string literals and various numeric literals:"
msgstr ""

#: ../Doc/reference/expressions.rst:122
msgid ""
"Evaluation of a literal yields an object of the given type (string, integer, "
"long integer, floating point number, complex number) with the given value.  "
"The value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: ../Doc/reference/expressions.rst:131
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Tous les littéraux sont de types immuables et donc l'identifiant de l'objet "
"est moins important que sa valeur. Des évaluations multiples de littéraux "
"avec la même valeur (soit la même occurrence dans le texte du programme, "
"soit une autre occurrence) résultent dans le même objet ou un objet "
"différent avec la même valeur."

#: ../Doc/reference/expressions.rst:141
msgid "Parenthesized forms"
msgstr "Formes parenthésées"

#: ../Doc/reference/expressions.rst:145
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""
"Une forme parenthésée est une liste d'expressions (cette liste est en fait "
"optionnelle) placée à l'intérieur de parenthèses :"

#: ../Doc/reference/expressions.rst:150
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"Une liste d'expressions entre parenthèses produit ce que la liste de ces "
"expressions produirait : si la liste contient au moins une virgule, elle "
"produit un n-uplet (type *tuple*) ; sinon, elle produit l'expression elle-"
"même (qui constitue donc elle-même la liste d'expressions)."

#: ../Doc/reference/expressions.rst:156
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the rules for literals apply (i.e., two occurrences of the empty "
"tuple may or may not yield the same object)."
msgstr ""
"Une paire de parenthèses vide produit un objet *tuple* vide. Comme les "
"*tuples* sont immuables, la règle pour les littéraux s'applique (c'est-à-"
"dire que deux occurrences du *tuple* vide peuvent, ou pas, produire le même "
"objet)."

#: ../Doc/reference/expressions.rst:164
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"Notez que les *tuples* ne sont pas créés par les parenthèses mais par "
"l'utilisation de la virgule. L'exception est le tuple vide, pour lequel les "
"parenthèses *sont requises* (autoriser que \"rien\" ne soit pas parenthésé "
"dans les expressions aurait généré des ambigüités et aurait permis à "
"certaines coquilles de passer inaperçu)."

#: ../Doc/reference/expressions.rst:173
msgid "List displays"
msgstr "Agencements de listes"

#: ../Doc/reference/expressions.rst:179
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"Un agencement de liste est une suite (possiblement vide) d'expressions à "
"l'intérieur de crochets :"

#: ../Doc/reference/expressions.rst:196
msgid ""
"A list display yields a new list object.  Its contents are specified by "
"providing either a list of expressions or a list comprehension.  When a "
"comma-separated list of expressions is supplied, its elements are evaluated "
"from left to right and placed into the list object in that order.  When a "
"list comprehension is supplied, it consists of a single expression followed "
"by at least one :keyword:`for` clause and zero or more :keyword:`for` or :"
"keyword:`if` clauses.  In this case, the elements of the new list are those "
"that would be produced by considering each of the :keyword:`for` or :keyword:"
"`if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce a list element each time the innermost block is "
"reached [#]_."
msgstr ""

#: ../Doc/reference/expressions.rst:211
msgid "Displays for sets and dictionaries"
msgstr ""

#: ../Doc/reference/expressions.rst:213
msgid ""
"For constructing a set or a dictionary Python provides special syntax called "
"\"displays\", each of them in two flavors:"
msgstr ""

#: ../Doc/reference/expressions.rst:216
msgid "either the container contents are listed explicitly, or"
msgstr "soit le contenu du conteneur est listé explicitement,"

#: ../Doc/reference/expressions.rst:218
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"soit il est calculé à l'aide de la combinaison d'une boucle et "
"d'instructions de filtrage, appelée une :dfn:`compréhension` (dans le sens "
"de ce qui sert à définir un concept, par opposition à *extension*)."

#: ../Doc/reference/expressions.rst:221
msgid "Common syntax elements for comprehensions are:"
msgstr ""
"Les compréhensions sont constituées des éléments de syntaxe communs "
"suivants :"

#: ../Doc/reference/expressions.rst:229
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if` "
"clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""
"Une compréhension est constituée par une seule expression suivie par au "
"moins une clause :keyword:`for` et zéro ou plus clauses :keyword:`for` ou :"
"keyword:`if`. Dans ce cas, les éléments du nouveau conteneur sont ceux qui "
"auraient été produits si l'on avait considéré toutes les clauses :keyword:"
"`for` ou :keyword:`if` comme des blocs, imbriqués de la gauche vers la "
"droite, et évalué l'expression pour produire un élément à chaque fois que le "
"bloc le plus imbriqué était atteint."

#: ../Doc/reference/expressions.rst:236
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""

#: ../Doc/reference/expressions.rst:243
msgid "Generator expressions"
msgstr "Générateurs (expressions)"

#: ../Doc/reference/expressions.rst:248
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"Une expression générateur est une notation concise pour un générateur, "
"entourée de parenthèses :"

#: ../Doc/reference/expressions.rst:253
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Une expression générateur produit un nouvel objet générateur. Sa syntaxe est "
"la même que celle des compréhensions, sauf qu'elle est entourée de "
"parenthèses au lieu de crochets ou d'accolades."

#: ../Doc/reference/expressions.rst:257
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`__next__` method is called for generator object (in the same fashion "
"as normal generators).  However, the leftmost :keyword:`for` clause is "
"immediately evaluated, so that an error produced by it can be seen before "
"any other possible error in the code that handles the generator expression.  "
"Subsequent :keyword:`for` clauses cannot be evaluated immediately since they "
"may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in "
"range(10) for y in bar(x))``."
msgstr ""

#: ../Doc/reference/expressions.rst:266
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for the detail."
msgstr ""

#: ../Doc/reference/expressions.rst:272
msgid "Dictionary displays"
msgstr "Agencements de dictionnaires"

#: ../Doc/reference/expressions.rst:278
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""
"Un agencement de dictionnaire est une série (possiblement vide) de couples "
"clés-valeurs entourée par des accolades :"

#: ../Doc/reference/expressions.rst:287
msgid "A dictionary display yields a new dictionary object."
msgstr "Un agencement de dictionnaire produit un nouvel objet dictionnaire."

#: ../Doc/reference/expressions.rst:289
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"Si une séquence (dont les éléments sont séparés par des virgules) de couples "
"clés-valeurs est fournie, les couples sont évalués de la gauche vers la "
"droite pour définir les entrées du dictionnaire : chaque objet clé est "
"utilisé comme clé dans le dictionnaire pour stocker la donnée "
"correspondante. Cela signifie que vous pouvez spécifier la même clé "
"plusieurs fois dans la liste des couples clés-valeurs et, dans ce cas, la "
"valeur finalement stockée dans le dictionnaire est la dernière donnée."

#: ../Doc/reference/expressions.rst:295
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"Une compréhension de dictionnaire, au contraire des compréhensions de listes "
"ou d'ensembles, requiert deux expressions séparées par une virgule et "
"suivies par les clauses usuelles \"for\" et \"if\". Quand la compréhension "
"est exécutée, les éléments clés-valeurs sont insérés dans le nouveau "
"dictionnaire dans l'ordre dans lequel ils sont produits."

#: ../Doc/reference/expressions.rst:303
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Les restrictions relatives aux types des clés sont données dans la section :"
"ref:`types` (pour résumer, le type de la clé doit être :term:`hachable "
"<hashable>`, ce qui exclut tous les objets muables). Les collisions entre "
"les clés dupliquées ne sont pas détectées ; la dernière valeur (celle qui "
"apparaît le plus à droite dans l'agencement) stockée prévaut pour une clé "
"donnée."

#: ../Doc/reference/expressions.rst:313
msgid "Set displays"
msgstr "Agencements d'ensembles"

#: ../Doc/reference/expressions.rst:318
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"Un agencement d'ensemble (type *set*) est délimité par des accolades et se "
"distingue de l'agencement d'un dictionnaire par le fait qu'il n'y a pas de "
"\"deux points\" ``:`` pour séparer les clés et les valeurs :"

#: ../Doc/reference/expressions.rst:324
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Un agencement d'ensemble produit un nouvel objet ensemble muable, le contenu "
"étant spécifié soit par une séquence d'expression, soit par une "
"compréhension. Quand une liste (dont les éléments sont séparés par des "
"virgules) est fournie, ses éléments sont évalués de la gauche vers la droite "
"et ajoutés à l'objet ensemble. Quand une compréhension est fournie, "
"l'ensemble est construit à partir des éléments produits par la compréhension."

#: ../Doc/reference/expressions.rst:330
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"Un ensemble vide ne peut pas être construit par ``{}`` ; cette écriture "
"construit un dictionnaire vide."

#: ../Doc/reference/expressions.rst:337
msgid "String conversions"
msgstr ""

#: ../Doc/reference/expressions.rst:345
msgid ""
"A string conversion is an expression list enclosed in reverse (a.k.a. "
"backward) quotes:"
msgstr ""

#: ../Doc/reference/expressions.rst:351
msgid ""
"A string conversion evaluates the contained expression list and converts the "
"resulting object into a string according to rules specific to its type."
msgstr ""

#: ../Doc/reference/expressions.rst:354
msgid ""
"If the object is a string, a number, ``None``, or a tuple, list or "
"dictionary containing only objects whose type is one of these, the resulting "
"string is a valid Python expression which can be passed to the built-in "
"function :func:`eval` to yield an expression with the same value (or an "
"approximation, if floating point numbers are involved)."
msgstr ""

#: ../Doc/reference/expressions.rst:360
msgid ""
"(In particular, converting a string adds quotes around it and converts "
"\"funny\" characters to escape sequences that are safe to print.)"
msgstr ""

#: ../Doc/reference/expressions.rst:365
msgid ""
"Recursive objects (for example, lists or dictionaries that contain a "
"reference to themselves, directly or indirectly) use ``...`` to indicate a "
"recursive reference, and the result cannot be passed to :func:`eval` to get "
"an equal value (:exc:`SyntaxError` will be raised instead)."
msgstr ""

#: ../Doc/reference/expressions.rst:374
msgid ""
"The built-in function :func:`repr` performs exactly the same conversion in "
"its argument as enclosing it in parentheses and reverse quotes does.  The "
"built-in function :func:`str` performs a similar but more user-friendly "
"conversion."
msgstr ""

#: ../Doc/reference/expressions.rst:382
msgid "Yield expressions"
msgstr "Expressions ``yield``"

#: ../Doc/reference/expressions.rst:395
msgid ""
"The :keyword:`yield` expression is only used when defining a generator "
"function, and can only be used in the body of a function definition. Using "
"a :keyword:`yield` expression in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""

#: ../Doc/reference/expressions.rst:400
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of a generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first :keyword:`yield` "
"expression, where it is suspended again, returning the value of :token:"
"`expression_list` to generator's caller.  By suspended we mean that all "
"local state is retained, including the current bindings of local variables, "
"the instruction pointer, and the internal evaluation stack.  When the "
"execution is resumed by calling one of the generator's methods, the function "
"can proceed exactly as if the :keyword:`yield` expression was just another "
"external call. The value of the :keyword:`yield` expression after resuming "
"depends on the method which resumed the execution."
msgstr ""

#: ../Doc/reference/expressions.rst:415
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where should the execution continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""

#: ../Doc/reference/expressions.rst:425
msgid "Generator-iterator methods"
msgstr "Méthodes des générateurs-itérateurs"

#: ../Doc/reference/expressions.rst:427
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"Cette sous-section décrit les méthodes des générateurs-itérateurs. Elles "
"peuvent être utilisées pour contrôler l'exécution des fonctions générateurs."

#: ../Doc/reference/expressions.rst:430
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Notez que l'appel à une méthode ci-dessous d'un générateur alors que le "
"générateur est déjà en cours d'exécution lève une exception :exc:"
"`ValueError`."

#: ../Doc/reference/expressions.rst:438
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed :keyword:`yield` expression.  When a generator function is resumed "
"with a :meth:`~generator.next` method, the current :keyword:`yield` "
"expression always evaluates to :const:`None`.  The execution then continues "
"to the next :keyword:`yield` expression, where the generator is suspended "
"again, and the value of the :token:`expression_list` is returned to :meth:"
"`~generator.next`'s caller. If the generator exits without yielding another "
"value, a :exc:`StopIteration` exception is raised."
msgstr ""

#: ../Doc/reference/expressions.rst:451
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The ``value`` argument becomes the result of the current :keyword:`yield` "
"expression.  The :meth:`send` method returns the next value yielded by the "
"generator, or raises :exc:`StopIteration` if the generator exits without "
"yielding another value. When :meth:`send` is called to start the generator, "
"it must be called with :const:`None` as the argument, because there is no :"
"keyword:`yield` expression that could receive the value."
msgstr ""

#: ../Doc/reference/expressions.rst:462
msgid ""
"Raises an exception of type ``type`` at the point where generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""

#: ../Doc/reference/expressions.rst:473
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator "
"raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr ""

#: ../Doc/reference/expressions.rst:481
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Voici un exemple simple qui montre le comportement des générateurs et des "
"fonctions générateurs ::"

#: ../Doc/reference/expressions.rst:512
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` -- Coroutines *via* des générateurs améliorés"

#: ../Doc/reference/expressions.rst:512
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"Proposition d'améliorer l'API et la syntaxe des générateurs, de manière à "
"pouvoir les utiliser comme de simples coroutines."

#: ../Doc/reference/expressions.rst:519
msgid "Primaries"
msgstr "Primaires"

#: ../Doc/reference/expressions.rst:523
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Les primaires (*primary* dans la grammaire formelle ci-dessous) représentent "
"les opérations qui se lient au plus proche dans le langage. Leur syntaxe "
"est :"

#: ../Doc/reference/expressions.rst:533
msgid "Attribute references"
msgstr "Références à des attributs"

#: ../Doc/reference/expressions.rst:537
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""
"Une référence à un attribut (*attributeref* dans la grammaire formelle ci-"
"dessous) est une primaire suivie par un point et un nom :"

#: ../Doc/reference/expressions.rst:547
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, e.g., a module, list, or an instance.  This object is then asked "
"to produce the attribute whose name is the identifier.  If this attribute is "
"not available, the exception :exc:`AttributeError` is raised. Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""

#: ../Doc/reference/expressions.rst:558
msgid "Subscriptions"
msgstr "Sélections"

#: ../Doc/reference/expressions.rst:571
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""
"Une sélection (*subscription* dans la grammaire formelle ci-dessous) désigne "
"un élément dans un objet séquence (chaîne, n-uplet ou liste) ou tableau de "
"correspondances (dictionnaire) :"

#: ../Doc/reference/expressions.rst:577
msgid "The primary must evaluate to an object of a sequence or mapping type."
msgstr ""

#: ../Doc/reference/expressions.rst:579
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""
"Si la primaire est un tableau de correspondances, la liste d'expressions "
"(*expression_list* dans la grammaire formelle ci-dessous) doit pouvoir être "
"évaluée comme un objet dont la valeur est une des clés du tableau de "
"correspondances et la sélection désigne la valeur qui correspond à cette clé "
"(la liste d'expressions est un n-uplet sauf si elle comporte exactement un "
"élément)."

#: ../Doc/reference/expressions.rst:584
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to a plain "
"integer.  If this value is negative, the length of the sequence is added to "
"it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting "
"value must be a nonnegative integer less than the number of items in the "
"sequence, and the subscription selects the item whose index is that value "
"(counting from zero)."
msgstr ""

#: ../Doc/reference/expressions.rst:595
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""
"Les éléments des chaînes sont des caractères. Un caractère n'est pas un type "
"en tant que tel, c'est une chaîne de longueur un."

#: ../Doc/reference/expressions.rst:602
msgid "Slicings"
msgstr "Tranches"

#: ../Doc/reference/expressions.rst:614
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Une tranche (*slicing* dans la grammaire formelle ci-dessous) sélectionne un "
"intervalle d'éléments d'un objet séquence (par exemple une chaîne, un n-"
"uplet ou une liste, respectivement les types *string*, *tuple* et *list*). "
"Les tranches peuvent être utilisées comme des expressions ou des cibles dans "
"les assignations ou les instructions :keyword:`del`. La syntaxe est la "
"suivante :"

#: ../Doc/reference/expressions.rst:634
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice nor ellipses).  "
"Similarly, when the slice list has exactly one short slice and no trailing "
"comma, the interpretation as a simple slicing takes priority over that as an "
"extended slicing."
msgstr ""

#: ../Doc/reference/expressions.rst:643
msgid ""
"The semantics for a simple slicing are as follows.  The primary must "
"evaluate to a sequence object.  The lower and upper bound expressions, if "
"present, must evaluate to plain integers; defaults are zero and the ``sys."
"maxint``, respectively.  If either bound is negative, the sequence's length "
"is added to it.  The slicing now selects all items with index *k* such that "
"``i <= k < j`` where *i* and *j* are the specified lower and upper bounds.  "
"This may be an empty sequence.  It is not an error if *i* or *j* lie outside "
"the range of valid indexes (such items don't exist so they aren't selected)."
msgstr ""

#: ../Doc/reference/expressions.rst:657
msgid ""
"The semantics for an extended slicing are as follows.  The primary must "
"evaluate to a mapping object, and it is indexed with a key that is "
"constructed from the slice list, as follows.  If the slice list contains at "
"least one comma, the key is a tuple containing the conversion of the slice "
"items; otherwise, the conversion of the lone slice item is the key.  The "
"conversion of a slice item that is an expression is that expression.  The "
"conversion of an ellipsis slice item is the built-in ``Ellipsis`` object.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""

#: ../Doc/reference/expressions.rst:678
msgid "Calls"
msgstr "Appels"

#: ../Doc/reference/expressions.rst:680
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Un appel (*call* dans la grammaire ci-dessous) appelle un objet appelable "
"(par exemple, une :term:`fonction <function>`) avec, possiblement, une liste "
"d'\\ :term:`arguments <argument>` :"

#: ../Doc/reference/expressions.rst:697
msgid ""
"A trailing comma may be present after the positional and keyword arguments "
"but does not affect the semantics."
msgstr ""

#: ../Doc/reference/expressions.rst:703
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and certain class instances themselves are callable; "
"extensions may define additional callable object types).  All argument "
"expressions are evaluated before the call is attempted.  Please refer to "
"section :ref:`function` for the syntax of formal :term:`parameter` lists."
msgstr ""

#: ../Doc/reference/expressions.rst:710
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""
"Si des arguments par mots-clés sont présents, ils sont d'abord convertis en "
"arguments positionnels, comme suit. Pour commencer, une liste de *slots* "
"vides est créée pour les paramètres formels. S'il y a N arguments "
"positionnels, ils sont placés dans les N premiers *slots*. Ensuite, pour "
"chaque argument par mot-clé, l'identifiant est utilisé pour déterminer le "
"*slot* correspondant (si l'identifiant est le même que le nom du premier "
"paramètre formel, le premier *slot* est utilisé, et ainsi de suite). Si le "
"*slot* est déjà rempli, une exception :exc:`TypeError` est levée. Sinon, la "
"valeur de l'argument est placée dans le *slot*, ce qui le remplit (même si "
"l'expression est ``None``, cela remplit le *slot*). Quand tous les arguments "
"ont été traités, les *slots* qui sont toujours vides sont remplis avec la "
"valeur par défaut correspondante dans la définition de la fonction (les "
"valeurs par défaut sont calculées, une seule fois, lorsque la fonction est "
"définie ; ainsi, un objet mutable tel qu'une liste ou un dictionnaire "
"utilisé en tant valeur par défaut sera partagé entre tous les appels qui ne "
"spécifient pas de valeur d argument pour ce *slot* ; on évite généralement "
"de faire ça). S'il reste des *slots* pour lesquels aucune valeur par défaut "
"n'est définie, une exception :exc:`TypeError` est levée. Sinon, la liste des "
"*slots* remplie est utilisée en tant que liste des arguments pour l'appel."

#: ../Doc/reference/expressions.rst:730
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"Une implémentation peut fournir des fonctions natives dont les paramètres "
"positionnels n'ont pas de nom, même s'ils sont \"nommés\" pour les besoins "
"de la documentation. Ils ne peuvent donc pas être spécifiés par mot-clé. En "
"CPython, les fonctions implémentées en C qui utilisent :c:func:"
"`PyArg_ParseTuple` pour analyser leurs arguments en font partie."

#: ../Doc/reference/expressions.rst:736
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"S'il y a plus d'arguments positionnels que de *slots* de paramètres formels, "
"une exception :exc:`TypeError` est levée, à moins qu'un paramètre formel "
"n'utilise la syntaxe ``*identifier`` ; dans ce cas, le paramètre formel "
"reçoit un n-uplet contenant les arguments positionnels en supplément (ou un "
"n-uplet vide s'il n'y avait pas d'arguments positionnel en trop)."

#: ../Doc/reference/expressions.rst:742
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Si un argument par mot-clé ne correspond à aucun nom de paramètre formel, "
"une exception :exc:`TypeError` est levée, à moins qu'un paramètre formel "
"n'utilise la syntaxe ``**identifier`` ; dans ce cas, le paramètre formel "
"reçoit un dictionnaire contenant les arguments par mot-clé en trop (en "
"utilisant les mots-clés comme clés et les arguments comme valeurs pour ce "
"dictionnaire), ou un (nouveau) dictionnaire vide s'il n'y a pas d'argument "
"par mot-clé en trop."

#: ../Doc/reference/expressions.rst:752
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an iterable.  Elements from this iterable are treated as if "
"they were additional positional arguments; if there are positional arguments "
"*x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, "
"*y1*, ..., *yM*."
msgstr ""

#: ../Doc/reference/expressions.rst:759
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""

#: ../Doc/reference/expressions.rst:775
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""
"Il est inhabituel que les syntaxes d'arguments par mots-clés et "
"``*expression`` soient utilisés simultanément dans un même appel, ce qui "
"fait que la confusion reste hypothétique."

#: ../Doc/reference/expressions.rst:781
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr ""

#: ../Doc/reference/expressions.rst:786
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names.  "
"Formal parameters using the syntax ``(sublist)`` cannot be used as keyword "
"argument names; the outermost sublist corresponds to a single unnamed "
"argument slot, and the argument value is assigned to the sublist using the "
"usual tuple assignment rules after all other parameter processing is done."
msgstr ""

#: ../Doc/reference/expressions.rst:793
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Un appel renvoie toujours une valeur, possiblement ``None``, à moins qu'il "
"ne lève une exception. La façon dont celle valeur est calculée dépend du "
"type de l'objet appelable."

#: ../Doc/reference/expressions.rst:797
msgid "If it is---"
msgstr "Si c'est ---"

#: ../Doc/reference/expressions.rst:810
msgid "a user-defined function:"
msgstr "une fonction définie par l'utilisateur :"

#: ../Doc/reference/expressions.rst:806
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"le bloc de code de la fonction est exécuté, il reçoit la liste des "
"arguments. La première chose que le bloc de code fait est de lier les "
"paramètres formels aux arguments ; ceci est décrit dans la section :ref:"
"`function`. Quand le bloc de code exécute l'instruction :keyword:`return`, "
"cela spécifie la valeur de retour de l'appel de la fonction."

#: ../Doc/reference/expressions.rst:824
msgid "a built-in function or method:"
msgstr "une fonction ou une méthode native :"

#: ../Doc/reference/expressions.rst:823
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"le résultat dépend de l'interpréteur ; lisez :ref:`built-in-funcs` pour une "
"description des fonctions et méthodes natives."

#: ../Doc/reference/expressions.rst:831
msgid "a class object:"
msgstr "un objet classe :"

#: ../Doc/reference/expressions.rst:831
msgid "A new instance of that class is returned."
msgstr "une nouvelle instance de cette classe est renvoyée."

#: ../Doc/reference/expressions.rst:841
msgid "a class instance method:"
msgstr "une méthode d'instance de classe :"

#: ../Doc/reference/expressions.rst:839
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"la fonction correspondante définie par l'utilisateur est appelée, avec la "
"liste d'arguments qui est plus grande d'un élément que la liste des "
"arguments de l'appel : l'instance est placée en tête des arguments."

#: ../Doc/reference/expressions.rst:850
msgid "a class instance:"
msgstr "une instance de classe :"

#: ../Doc/reference/expressions.rst:848
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""
"la classe doit définir une méthode :meth:`__call__` ; l'effet est le même "
"que si cette méthode était appelée."

#: ../Doc/reference/expressions.rst:855
msgid "The power operator"
msgstr "L'opérateur puissance"

#: ../Doc/reference/expressions.rst:857
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"L'opérateur puissance est plus prioritaire que les opérateurs unaires sur sa "
"gauche ; il est moins prioritaire que les opérateurs unaires sur sa droite. "
"La syntaxe est :"

#: ../Doc/reference/expressions.rst:863
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Ainsi, dans une séquence sans parenthèse de puissance et d'opérateurs "
"unaires, les opérateurs sont évalués de droite à gauche (ceci ne contraint "
"pas l'ordre d'évaluation des opérandes) : ``-1**2`` donne ``-1``."

#: ../Doc/reference/expressions.rst:867
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type.  The result type is that of the arguments after "
"coercion."
msgstr ""

#: ../Doc/reference/expressions.rst:872
msgid ""
"With mixed operand types, the coercion rules for binary arithmetic operators "
"apply. For int and long int operands, the result has the same type as the "
"operands (after coercion) unless the second argument is negative; in that "
"case, all arguments are converted to float and a float result is delivered. "
"For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``. "
"(This last feature was added in Python 2.2. In Python 2.1 and before, if "
"both arguments were of integer types and the second argument was negative, "
"an exception was raised)."
msgstr ""

#: ../Doc/reference/expressions.rst:881
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :exc:"
"`ValueError`."
msgstr ""

#: ../Doc/reference/expressions.rst:888
msgid "Unary arithmetic and bitwise operations"
msgstr "Arithmétique unaire et opérations sur les bits"

#: ../Doc/reference/expressions.rst:894
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Toute l'arithmétique unaire et les opérations sur les bits ont la même "
"priorité :"

#: ../Doc/reference/expressions.rst:903
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""
"L'opérateur unaire ``-`` (moins) produit l'opposé de son argument numérique."

#: ../Doc/reference/expressions.rst:907
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""
"L'opérateur unaire ``+`` (plus) produit son argument numérique inchangé."

#: ../Doc/reference/expressions.rst:911
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its plain "
"or long integer argument.  The bitwise inversion of ``x`` is defined as ``-(x"
"+1)``.  It only applies to integral numbers."
msgstr ""

#: ../Doc/reference/expressions.rst:917
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"Dans ces trois cas, si l'argument n'est pas du bon type, une exception :exc:"
"`TypeError` est levée."

#: ../Doc/reference/expressions.rst:924
msgid "Binary arithmetic operations"
msgstr "Opérations arithmétiques binaires"

#: ../Doc/reference/expressions.rst:928
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"Les opérations arithmétiques binaires suivent les conventions pour les "
"priorités. Notez que certaines de ces opérations s'appliquent aussi à des "
"types non numériques. À part l'opérateur puissance, il n'y a que deux "
"niveaux, le premier pour les opérateurs multiplicatifs et le second pour les "
"opérateurs additifs :"

#: ../Doc/reference/expressions.rst:940
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer (plain or long) and the other must be a sequence. In the former "
"case, the numbers are converted to a common type and then multiplied "
"together.  In the latter case, sequence repetition is performed; a negative "
"repetition factor yields an empty sequence."
msgstr ""

#: ../Doc/reference/expressions.rst:951
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Plain or long integer division yields an integer of the same "
"type; the result is that of mathematical division with the 'floor' function "
"applied to the result. Division by zero raises the :exc:`ZeroDivisionError` "
"exception."
msgstr ""

#: ../Doc/reference/expressions.rst:959
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"L'opérateur ``%`` (modulo) produit le reste de la division entière du "
"premier argument par le second. Les arguments numériques sont d'abord "
"convertis vers un type commun. Un zéro en second argument lève une "
"exception :exc:`ZeroDivisionError`. Les arguments peuvent être des nombres à "
"virgule flottante, par exemple ``3.14%0.7`` vaut ``0.34`` (puisque ``3.14`` "
"égale ``4*0.7+0.34``). L'opérateur modulo produit toujours un résultat du "
"même signe que le second opérande (ou zéro) ; la valeur absolue du résultat "
"est strictement inférieure à la valeur absolue du second opérande [#]_."

#: ../Doc/reference/expressions.rst:968
msgid ""
"The integer division and modulo operators are connected by the following "
"identity: ``x == (x/y)*y + (x%y)``.  Integer division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x/y, "
"x%y)``.  These identities don't hold for floating point numbers; there "
"similar identities hold approximately where ``x/y`` is replaced by ``floor(x/"
"y)`` or ``floor(x/y) - 1`` [#]_."
msgstr ""

#: ../Doc/reference/expressions.rst:975
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string and unicode objects to perform string "
"formatting (also known as interpolation). The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`string-"
"formatting`."
msgstr ""

#: ../Doc/reference/expressions.rst:980
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../Doc/reference/expressions.rst:987
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments. The arguments "
"must either both be numbers or both sequences of the same type.  In the "
"former case, the numbers are converted to a common type and then added "
"together.  In the latter case, the sequences are concatenated."
msgstr ""

#: ../Doc/reference/expressions.rst:994
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""
"L'opérateur ``-`` (soustraction) produit la différence entre ses arguments. "
"Les arguments numériques sont d'abord convertis vers un type commun."

#: ../Doc/reference/expressions.rst:1001
msgid "Shifting operations"
msgstr "Opérations de décalage"

#: ../Doc/reference/expressions.rst:1005
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Les opérations de décalage sont moins prioritaires que les opérations "
"arithmétiques :"

#: ../Doc/reference/expressions.rst:1010
msgid ""
"These operators accept plain or long integers as arguments.  The arguments "
"are converted to a common type.  They shift the first argument to the left "
"or right by the number of bits given by the second argument."
msgstr ""

#: ../Doc/reference/expressions.rst:1016
msgid ""
"A right shift by *n* bits is defined as division by ``pow(2, n)``.  A left "
"shift by *n* bits is defined as multiplication with ``pow(2, n)``.  Negative "
"shift counts raise a :exc:`ValueError` exception."
msgstr ""

#: ../Doc/reference/expressions.rst:1022
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:"
"`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""
"Dans l'implémentation actuelle, l'opérande de droite doit être au maximum :"
"attr:`sys.maxsize`. Si l'opérande de droite est plus grand que :attr:`sys."
"maxsize`, une exception  :exc:`OverflowError` est levée."

#: ../Doc/reference/expressions.rst:1029
msgid "Binary bitwise operations"
msgstr "Opérations binaires bit à bit"

#: ../Doc/reference/expressions.rst:1033
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""
"Chacune des trois opérations binaires bit à bit possède une priorité "
"différente :"

#: ../Doc/reference/expressions.rst:1042
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"plain or long integers.  The arguments are converted to a common type."
msgstr ""

#: ../Doc/reference/expressions.rst:1049
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be plain or long integers.  The arguments are converted to a "
"common type."
msgstr ""

#: ../Doc/reference/expressions.rst:1056
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be plain or long integers.  The arguments are converted to a common "
"type."
msgstr ""

#: ../Doc/reference/expressions.rst:1067
msgid "Comparisons"
msgstr "Comparaisons"

#: ../Doc/reference/expressions.rst:1073
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"Au contraire du C, toutes les opérations de comparaison en Python possèdent "
"la même priorité, qui est plus faible que celle des opérations "
"arithmétiques, décalages ou binaires bit à bit. Toujours contrairement au C, "
"les expressions telles que ``a < b < c`` sont interprétées comme elles le "
"seraient conventionnellement en mathématiques :"

#: ../Doc/reference/expressions.rst:1083
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""
"Les comparaisons produisent des valeurs booléennes : ``True`` ou ``False``."

#: ../Doc/reference/expressions.rst:1087
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Les comparaisons peuvent être enchaînées arbitrairement, par exemple ``x < y "
"<= z`` est équivalent à ``x < y and y <= z``, sauf que ``y`` est évalué "
"seulement une fois (mais dans les deux cas, ``z`` n'est pas évalué du tout "
"si ``x < y`` s'avère être faux)."

#: ../Doc/reference/expressions.rst:1091
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Formellement, si *a*, *b*, *c*, ..., *y*, *z* sont des expressions et *op1*, "
"*op2*, ..., *opN* sont des opérateurs de comparaison, alors ``a op1 b op2 "
"c ... y opN z`` est équivalent à ``a op1 b and b op2 c and ... y opN z``, "
"sauf que chaque expression est évaluée au maximum une fois."

#: ../Doc/reference/expressions.rst:1096
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Notez que ``a op1 b op2 c`` n'implique aucune comparaison entre *a* et *c*. "
"Ainsi, par exemple, ``x < y > z`` est parfaitement légal (mais peut-être pas "
"très élégant)."

#: ../Doc/reference/expressions.rst:1100
msgid ""
"The forms ``<>`` and ``!=`` are equivalent; for consistency with C, ``!=`` "
"is preferred; where ``!=`` is mentioned below ``<>`` is also accepted.  The "
"``<>`` spelling is considered obsolescent."
msgstr ""

#: ../Doc/reference/expressions.rst:1104
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects need not have the same type. If both are "
"numbers, they are converted to a common type.  Otherwise, objects of "
"different types *always* compare unequal, and are ordered consistently but "
"arbitrarily. You can control comparison behavior of objects of non-built-in "
"types by defining a ``__cmp__`` method or rich comparison methods like "
"``__gt__``, described in section :ref:`specialnames`."
msgstr ""

#: ../Doc/reference/expressions.rst:1112
msgid ""
"(This unusual definition of comparison was used to simplify the definition "
"of operations like sorting and the :keyword:`in` and :keyword:`not in` "
"operators. In the future, the comparison rules for objects of different "
"types are likely to change.)"
msgstr ""

#: ../Doc/reference/expressions.rst:1117
msgid "Comparison of objects of the same type depends on the type:"
msgstr ""

#: ../Doc/reference/expressions.rst:1119
msgid "Numbers are compared arithmetically."
msgstr ""

#: ../Doc/reference/expressions.rst:1121
msgid ""
"Strings are compared lexicographically using the numeric equivalents (the "
"result of the built-in function :func:`ord`) of their characters.  Unicode "
"and 8-bit strings are fully interoperable in this behavior. [#]_"
msgstr ""

#: ../Doc/reference/expressions.rst:1125
msgid ""
"Tuples and lists are compared lexicographically using comparison of "
"corresponding elements.  This means that to compare equal, each element must "
"compare equal and the two sequences must be of the same type and have the "
"same length."
msgstr ""

#: ../Doc/reference/expressions.rst:1130
msgid ""
"If not equal, the sequences are ordered the same as their first differing "
"elements.  For example, ``cmp([1,2,x], [1,2,y])`` returns the same as "
"``cmp(x,y)``.  If the corresponding element does not exist, the shorter "
"sequence is ordered first (for example, ``[1,2] < [1,2,3]``)."
msgstr ""

#: ../Doc/reference/expressions.rst:1135
msgid ""
"Mappings (dictionaries) compare equal if and only if their sorted (key, "
"value) lists compare equal. [#]_ Outcomes other than equality are resolved "
"consistently, but are not otherwise defined. [#]_"
msgstr ""

#: ../Doc/reference/expressions.rst:1139
msgid ""
"Most other objects of built-in types compare unequal unless they are the "
"same object; the choice whether one object is considered smaller or larger "
"than another one is made arbitrarily but consistently within one execution "
"of a program."
msgstr ""

#: ../Doc/reference/expressions.rst:1146
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for collection "
"membership.  ``x in s`` evaluates to true if *x* is a member of the "
"collection *s*, and false otherwise.  ``x not in s`` returns the negation of "
"``x in s``. The collection membership test has traditionally been bound to "
"sequences; an object is a member of a collection if the collection is a "
"sequence and contains an element equal to that object.  However, it make "
"sense for many other object types to support membership tests without being "
"a sequence.  In particular, dictionaries (for keys) and sets support "
"membership testing."
msgstr ""

#: ../Doc/reference/expressions.rst:1155
msgid ""
"For the list and tuple types, ``x in y`` is true if and only if there exists "
"an index *i* such that either ``x is y[i]`` or ``x == y[i]`` is true."
msgstr ""

#: ../Doc/reference/expressions.rst:1158
msgid ""
"For the Unicode and string types, ``x in y`` is true if and only if *x* is a "
"substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Note, *x* and "
"*y* need not be the same type; consequently, ``u'ab' in 'abc'`` will return "
"``True``. Empty strings are always considered to be a substring of any other "
"string, so ``\"\" in \"abc\"`` will return ``True``."
msgstr ""

#: ../Doc/reference/expressions.rst:1164
msgid "Previously, *x* was required to be a string of length ``1``."
msgstr ""

#: ../Doc/reference/expressions.rst:1167
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` is true if and only if ``y.__contains__(x)`` is true."
msgstr ""

#: ../Doc/reference/expressions.rst:1170
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is true if some value ``z`` with ``x == "
"z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""

#: ../Doc/reference/expressions.rst:1175
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is true if and only if there is a non-negative "
"integer index *i* such that ``x == y[i]``, and all lower integer indices do "
"not raise :exc:`IndexError` exception. (If any other exception is raised, it "
"is as if :keyword:`in` raised that exception)."
msgstr ""

#: ../Doc/reference/expressions.rst:1187
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of :"
"keyword:`in`."
msgstr ""
"L'opérateur  :keyword:`not in` est défini comme produisant le contraire de :"
"keyword:`in`."

#: ../Doc/reference/expressions.rst:1195
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""

#: ../Doc/reference/expressions.rst:1206
msgid "Boolean operations"
msgstr "Opérations booléennes"

#: ../Doc/reference/expressions.rst:1217
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  (See the :meth:"
"`~object.__nonzero__` special method for a way to change this.)"
msgstr ""

#: ../Doc/reference/expressions.rst:1226
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"L'opérateur :keyword:`not` produit ``True`` si son argument est faux, "
"``False`` sinon."

#: ../Doc/reference/expressions.rst:1231
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"L'expression ``x and y`` commence par évaluer *x* ; si *x* est faux, sa "
"valeur est renvoyée ; sinon, *y* est évalué et la valeur résultante est "
"renvoyée."

#: ../Doc/reference/expressions.rst:1236
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"L'expression ``x or y`` commence par évaluer *x* ; si *x* est vrai, sa "
"valeur est renvoyée ; sinon, *y* est évalué et la valeur résultante est "
"renvoyée."

#: ../Doc/reference/expressions.rst:1239
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument. This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"invent a value anyway, it does not bother to return a value of the same type "
"as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""

#: ../Doc/reference/expressions.rst:1249
msgid "Conditional Expressions"
msgstr ""

#: ../Doc/reference/expressions.rst:1261
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Les expressions conditionnelles (parfois appelées \"opérateur ternaire\") "
"sont les moins prioritaires de toutes les opérations Python."

#: ../Doc/reference/expressions.rst:1264
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* (*not* "
"*x*); if *C* is true, *x* is evaluated and its value is returned; otherwise, "
"*y* is evaluated and its value is returned."
msgstr ""

#: ../Doc/reference/expressions.rst:1268
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""
"Voir la :pep:`308` pour plus de détails sur les expressions conditionnelles."

#: ../Doc/reference/expressions.rst:1275
msgid "Lambdas"
msgstr "Expressions lambda"

#: ../Doc/reference/expressions.rst:1285
msgid ""
"Lambda expressions (sometimes called lambda forms) have the same syntactic "
"position as expressions.  They are a shorthand to create anonymous "
"functions; the expression ``lambda arguments: expression`` yields a function "
"object.  The unnamed object behaves like a function object defined with ::"
msgstr ""

#: ../Doc/reference/expressions.rst:1293
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements."
msgstr ""

#: ../Doc/reference/expressions.rst:1300
msgid "Expression lists"
msgstr "Listes d'expressions"

#: ../Doc/reference/expressions.rst:1309
msgid ""
"An expression list containing at least one comma yields a tuple.  The length "
"of the tuple is the number of expressions in the list.  The expressions are "
"evaluated from left to right."
msgstr ""

#: ../Doc/reference/expressions.rst:1315
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"La virgule finale est nécessaire pour créer un singleton (c'est-à-dire un n-"
"uplet composé d'un seul élément) : elle est optionnelle dans tous les autres "
"cas. Une expression seule sans virgule finale ne crée pas un n-uplet mais "
"produit la valeur de cette expression (pour créer un *tuple* vide, utilisez "
"une paire de parenthèses vide : ``()``)."

#: ../Doc/reference/expressions.rst:1325
msgid "Evaluation order"
msgstr "Ordre d'évaluation"

#: ../Doc/reference/expressions.rst:1329
msgid ""
"Python evaluates expressions from left to right. Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""

#: ../Doc/reference/expressions.rst:1332
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"Dans les lignes qui suivent, les expressions sont évaluées suivant l'ordre "
"arithmétique de leurs suffixes ::"

#: ../Doc/reference/expressions.rst:1346
msgid "Operator precedence"
msgstr "Priorités des opérateurs"

#: ../Doc/reference/expressions.rst:1350
msgid ""
"The following table summarizes the operator precedences in Python, from "
"lowest precedence (least binding) to highest precedence (most binding). "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for comparisons, including tests, which all have the "
"same precedence and chain from left to right --- see section :ref:"
"`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""

#: ../Doc/reference/expressions.rst:1359
msgid "Operator"
msgstr "Opérateur"

#: ../Doc/reference/expressions.rst:1359
msgid "Description"
msgstr "Description"

#: ../Doc/reference/expressions.rst:1361
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../Doc/reference/expressions.rst:1361
msgid "Lambda expression"
msgstr "Expression lambda"

#: ../Doc/reference/expressions.rst:1363
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ":keyword:`if` -- :keyword:`else`"

#: ../Doc/reference/expressions.rst:1363
msgid "Conditional expression"
msgstr "Expressions conditionnelle"

#: ../Doc/reference/expressions.rst:1365
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../Doc/reference/expressions.rst:1365
msgid "Boolean OR"
msgstr "OR (booléen)"

#: ../Doc/reference/expressions.rst:1367
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../Doc/reference/expressions.rst:1367
msgid "Boolean AND"
msgstr "AND (booléen)"

#: ../Doc/reference/expressions.rst:1369
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../Doc/reference/expressions.rst:1369
msgid "Boolean NOT"
msgstr "NOT (booléen)"

#: ../Doc/reference/expressions.rst:1371
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"
msgstr ""

#: ../Doc/reference/expressions.rst:1371
msgid "Comparisons, including membership tests and identity tests"
msgstr ""
"Comparaisons, y compris les tests d'appartenance et les tests d'identifiants"

#: ../Doc/reference/expressions.rst:1375
msgid "``|``"
msgstr "``|``"

#: ../Doc/reference/expressions.rst:1375
msgid "Bitwise OR"
msgstr "OR (bit à bit)"

#: ../Doc/reference/expressions.rst:1377
msgid "``^``"
msgstr "``^``"

#: ../Doc/reference/expressions.rst:1377
msgid "Bitwise XOR"
msgstr "XOR (bit à bit)"

#: ../Doc/reference/expressions.rst:1379
msgid "``&``"
msgstr "``&``"

#: ../Doc/reference/expressions.rst:1379
msgid "Bitwise AND"
msgstr "AND (bit à bit)"

#: ../Doc/reference/expressions.rst:1381
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../Doc/reference/expressions.rst:1381
msgid "Shifts"
msgstr "décalages"

#: ../Doc/reference/expressions.rst:1383
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../Doc/reference/expressions.rst:1383
msgid "Addition and subtraction"
msgstr "Addition et soustraction"

#: ../Doc/reference/expressions.rst:1385
msgid "``*``, ``/``, ``//``, ``%``"
msgstr ""

#: ../Doc/reference/expressions.rst:1385
msgid "Multiplication, division, remainder [#]_"
msgstr ""

#: ../Doc/reference/expressions.rst:1388
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../Doc/reference/expressions.rst:1388
msgid "Positive, negative, bitwise NOT"
msgstr "NOT (positif, négatif, bit à bit)"

#: ../Doc/reference/expressions.rst:1390
msgid "``**``"
msgstr "``**``"

#: ../Doc/reference/expressions.rst:1390
msgid "Exponentiation [#]_"
msgstr "Puissance [#]_"

#: ../Doc/reference/expressions.rst:1392
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""
"``x[indice]``, ``x[indice:indice]``, ``x(arguments...)``, ``x.attribut``"

#: ../Doc/reference/expressions.rst:1392
msgid "Subscription, slicing, call, attribute reference"
msgstr "indiçage, tranches, appel, référence à un attribut"

#: ../Doc/reference/expressions.rst:1395
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"```expressions...```"
msgstr ""

#: ../Doc/reference/expressions.rst:1395
msgid ""
"Binding or tuple display, list display, dictionary display, string conversion"
msgstr ""

#: ../Doc/reference/expressions.rst:1402
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/expressions.rst:1403
msgid ""
"In Python 2.3 and later releases, a list comprehension \"leaks\" the control "
"variables of each ``for`` it contains into the containing scope.  However, "
"this behavior is deprecated, and relying on it will not work in Python 3."
msgstr ""

#: ../Doc/reference/expressions.rst:1407
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Bien que ``abs(x%y) < abs(y)`` soit vrai mathématiquement, ce n'est pas "
"toujours vrai pour les nombres à virgule flottante en raison des arrondis. "
"Par exemple, en supposant que Python tourne sur une plateforme où les "
"*float* sont des nombres à double précision IEEE 754, afin que ``-1e-100 % "
"1e100`` soit du même signe que ``1e100``, le résultat calculé est ``-1e-100 "
"+ 1e100``, qui vaut exactement ``1e100`` dans ce standard. Or, la fonction :"
"func:`math.fmod` renvoie un résultat dont le signe est le signe du premier "
"argument, c'est-à-dire ``-1e-100`` dans ce cas. La meilleure approche dépend "
"de l'application."

#: ../Doc/reference/expressions.rst:1416
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``floor(x/y)`` to be one larger than ``(x-x%y)/y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""

#: ../Doc/reference/expressions.rst:1421
msgid ""
"While comparisons between unicode strings make sense at the byte level, they "
"may be counter-intuitive to users. For example, the strings ``u\"\\u00C7\"`` "
"and ``u\"\\u0043\\u0327\"`` compare differently, even though they both "
"represent the same unicode character (LATIN CAPITAL LETTER C WITH CEDILLA). "
"To compare strings in a human recognizable way, compare using :func:"
"`unicodedata.normalize`."
msgstr ""

#: ../Doc/reference/expressions.rst:1428
msgid ""
"The implementation computes this efficiently, without constructing lists or "
"sorting."
msgstr ""

#: ../Doc/reference/expressions.rst:1431
msgid ""
"Earlier versions of Python used lexicographic comparison of the sorted (key, "
"value) lists, but this was very expensive for the common case of comparing "
"for equality.  An even earlier version of Python compared dictionaries by "
"identity only, but this caused surprises because people expected to be able "
"to test a dictionary for emptiness by comparing it to ``{}``."
msgstr ""

#: ../Doc/reference/expressions.rst:1437
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"En raison du ramasse-miettes automatique et de la nature dynamique des "
"descripteurs, vous pouvez être confronté à un comportement semblant bizarre "
"lors de certaines utilisations de l'opérateur :keyword:`is`, par exemple si "
"cela implique des comparaisons entre des méthodes d'instances ou des "
"constantes. Allez vérifier dans la documentation pour plus d'informations."

#: ../Doc/reference/expressions.rst:1442
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"L'opérateur ``%`` est aussi utilisé pour formater les chaînes de "
"caractères ; il y possède la même priorité."

#: ../Doc/reference/expressions.rst:1445
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"L'opérateur puissance ``**`` est moins prioritaire qu'un opérateur unaire "
"arithmétique ou bit à bit sur sa droite. Ainsi, ``2**-1`` vaut ``0.5``."
